타사 사례 (비슷한 기능 운영 방식)
(1) Kore.ai XO Platform
Visual Flow Designer: 드래그 앤 드롭으로 Intent, API, 조건 분기 구성.
저장 → 배포: 워크플로우를 Bot Definition(JSON)으로 저장 후 “Publish”하면 REST API가 자동 생성됨.
API 제공: /bot/<botId>/message 같은 엔드포인트가 노출 → 다른 앱/채널에서 호출.
(2) Cognigy.AI
Flow Editor: 노드 기반 UI에서 API 호출, 조건, 반복 노드 구성.
저장: Flow가 DB에 JSON으로 저장됨.
API 제공: /v2/endpoint/<endpointId> 형태로 REST API 자동 생성. Slack, Webchat 등 채널에 연결 가능.
(3) Voiceflow
Drag & Drop Editor로 시나리오 설계.
Export/Versioning: JSON 또는 YAML로 내보내 GitHub에 저장 가능.
API Runtime: Voiceflow Runtime API를 호출하면 저장된 플로우대로 응답을 생성.

(4) Dialogflow CX (Google)
Flow Builder: Intents + Conditions + API Calls 구성.
저장/버전 관리: Flow가 Google Cloud 내부에 JSON 스키마로 저장.
API 제공: projects/<projectId>/locations/global/agents/<agentId>/sessions API에서 실행.
3. 실제 운영 Best Practice
Studio → DSL Export
Studio에서 만든 Flow를 YAML/JSON으로 export.
버전 태깅 후 Git 저장소 or DB에서 관리.
Core → API Registry
DSL 파일을 Core에 등록 (예: /configs/workflows/ 폴더에 저장).
Core가 /api/v1/workflow/<workflow_id>/execute 식으로 API 자동 생성.

외부 연동
상담 UI, ERP, CRM, 챗봇 채널(카카오, Slack 등)에서 해당 API 호출.
운영팀은 Studio에서 시나리오를 바꾸고 다시 Publish → 곧바로 API 갱신.

✅ 정리
Kainexa도 Kore.ai, Cognigy, Voiceflow처럼
Studio는 시나리오 제작/저장용 (DSL export)
Core는 실행/배포 API 제공용
으로 분리하는 게 맞습니다.
즉, 운영에서 “저장하면 API가 생기는 구조”를 만들려면, Studio에서 만든 DSL을 Core API에 등록 → Core가 엔드포인트를 자동 노출하는 식으로 가야 합니다.
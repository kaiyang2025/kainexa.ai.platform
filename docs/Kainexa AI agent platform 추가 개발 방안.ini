0) 목표와 범위

목표: Studio에서 드래그앤드롭으로 만든 워크플로우를 **DSL(YAML/JSON)**로 저장하고, Core에 업로드→컴파일→시뮬레이션→퍼블리시하여, 표준 REST 실행 API로 노출·운영.

범위:

운영자 매뉴얼 플로우(저장→배포→API 호출) 제품화

투자자·고객 제안서에 바로 쓰는 아키텍처 다이어그램/메시지

즉시 착수 가능한 구현 계획(모듈·API·DB·CI/CD·보안·모니터링·타임라인)

1) 하이레벨 아키텍처 (IR/제안서용 다이어그램)
[Business Apps / Channels]
  • WebChat • Mobile • Kakao/LINE • CRM/ERP • Helpdesk

          │ HTTPS (JWT)
          ▼
 ┌───────────────────────────┐
 │        Kainexa Core       │
 │ ───────────────────────── │
 │  Workflow Registry (DB)   │  ← Studio Export DSL 저장/버전/환경
 │  Compiler/Validator       │  ← DSL→실행그래프 컴파일/스키마검증/정책검증
 │  Policy Engine            │  ← SLA/비용/Fallback/Escalation 가드레일
 │  Graph Executor           │  ← Intent/LLM/API/조건/반복 실행
 │  Model Router             │  ← 대형↔경량 LLM 라우팅·요약·재시도
 │  Observability            │  ← Trace/Logs/Metrics/Cost/PII Mask
 └───────────┬──────────────┘
             │ gRPC/HTTP
             ▼
     [Models & Data Plane]
   • LLMs (Solar-10.7B, SLM-ko)
   • RAG (Vector DB, KB)
   • Tools/APIs (ERP, Payments)

             ▲
             │ Publish/Activate
 ┌───────────┴──────────────┐
 │       Kainexa Studio      │
 │  Visual Flow Editor       │  ← 드래그앤드롭(의도/LLM/API/조건/반복)
 │  Simulate & A/B Test      │  ← 샘플입력/감정/성능 비교
 │  Export DSL (YAML/JSON)   │  ← Git/DB 버전관리
 │  Publish to Core          │  ← Dev/Stage/Prod 배포
 └───────────────────────────┘


핵심 메시지(한 장 요약)

No-Code→API 자동화: Studio에서 만든 플로우가 버전 태깅 후 Core에 Publish되면 곧바로 표준 REST 실행 API로 노출.
엔터프라이즈 거버넌스: 정책(SLA/비용/승격)·감사·추적이 기본 탑재, 장애 시 1-클릭 롤백.
한국형 경쟁력: 한국어 존댓말·감정·도메인 용어·국내 시스템(카카오/더존/PG) 레퍼런스.
비용/성능 최적화: 대형모델은 중요한 턴에만, 평시 경량모델+RAG로 정확도/비용 동시 관리.
실증 KPI: 자동화율/응답시간/해결률/CSAT/토큰비용을 대시보드로 실시간 제시 → PoC→상용 전환 가속.

2) 운영자 매뉴얼(제품 기능화) — “저장 → 배포 → API 호출”
A. 저장(Studio → DSL Export)
UX: “저장” 클릭 → 워크플로우(노드/엣지/프로퍼티)를 **DSL(YAML/JSON)**로 변환.
파일 규칙:
workflows/{namespace}/{name}/{name}-{semver}-{yyyymmdd-hhmm}-{gitsha}.yaml
예) workflows/cs/ecommerce/refund-flow/refund-flow-1.3.2-20250930-1012-4f2c9a.yaml

버전관리: GitOps(권장) + Core Registry DB 동시 기록.

B. 배포(등록→컴파일→시뮬레이션→퍼블리시)
등록 /workflows (DSL 업로드)
컴파일 /workflows/compile (스키마·정책·경로 검증)
시뮬레이션 /workflows/simulate (샘플 입력/컨텍스트)
퍼블리시 /workflows/publish (Dev/Stage/Prod 활성화)
롤백: /workflows/activate로 이전 버전 활성화

C. 실행(API 호출)

표준 엔드포인트:
POST /workflow/{namespace}/{name}/execute
Body: { session_id, input{...}, context{channel, language, tenant_id...} }
응답: execution_id, reply/intents/actions, metrics(latency/tokens/model), trace_url.

D. 운영 가드레일
권한: admin(publish/activate), editor(upload/compile/simulate), viewer(read), service(execute).
정책: latency_sla_ms, fallback(모델스위치), escalation(상담사/큐)
모니터링: Latency/Success/Automation/TokenCost 4대 고정 지표 + 에러 알림(Slack/Webhook).
환경 분리: Dev/Stage/Prod 각자 모델풀·벡터DB·Redis 격리.

3) 구현 상세 (모듈/데이터/엔드포인트/보안)
3.1 주요 서비스 모듈
studio-web (Next/React)
Flow Canvas + Node Palette(의도/LLM/API/조건/반복)
DSL Exporter/Importer (YAML/JSON)
Publisher (Core REST 호출: upload/compile/simulate/publish)
A/B Test, Preview
core-api (FastAPI/uvicorn)
Workflow Registry (등록/조회/버전/환경)
Compiler/Validator (pydantic schema + 규칙검증)
Simulator (Mock KB/Mock API/샘플 컨텍스트)
Publisher/Activator (Env Slot: dev/stage/prod)
Executor (Graph 실행 엔진)
Policy Engine (SLA, Fallback, Escalation)
Model Router (LLM 라우팅·요약·재시도)
Observability (OpenTelemetry + Prom + Loki)
model-runtime

LLM(대/중/경량), 토큰화, 프롬프트 템플릿
RAG(VectorDB: Qdrant/FAISS), KB 어댑터
Tools/Connectors(ERP/CRM/PG/메신저)

3.2 데이터 모델(Registry DB)
Tables
workflows (id, namespace, name, description, created_by, created_at)
workflow_versions (workflow_id FK, version, dsl_raw, compiled_graph, status[uploaded|compiled|published], checksums, created_at)
env_routes (workflow_id, env(dev|stage|prod), active_version)
executions (execution_id, workflow_id, version, tenant_id, latency_ms, status, model, tokens_in, tokens_out, error_code, trace_id, created_at)

3.3 핵심 엔드포인트(요약)
POST /workflows — DSL 업로드
POST /workflows/compile — 컴파일/검증
POST /workflows/simulate — 샘플 입력 기반 시뮬
POST /workflows/publish — 배포(퍼블리시)
POST /workflows/activate — 특정 버전 활성화(롤백)
GET /workflows/meta?workflow_id=... — 버전/메타 조회
POST /workflow/{namespace}/{name}/execute — 실행 API(권장)
OpenAPI는 이전에 드린 3.1 스펙 그대로 사용하면 됩니다(서버 주소/클레임만 로컬 환경에 맞추면 끝).

3.4 보안/권한
JWT Bearer (sub/role/permissions/tenant_id/aud/iss/exp)
스코프 예시:
workflow:upload/compile/simulate/publish/read/execute
PII 보호: 입력/출력 마스킹 모듈(정규식+NER), 마스킹 전/후 샘플링 점검.
레이트리밋/IP Allowlist, 서명된 웹훅(실행 이벤트 발행 시).

4) Studio 측 개발 계획 (프론트)
4.1 주요 작업
DSL Exporter/Importer
노드·엣지·프로퍼티 → YAML/JSON 양방향 변환 유틸
노드 타입 스키마 고정(의도/LLM/API/조건/반복) + 유효성 검사
Publisher 패널
버튼: 업로드→컴파일→시뮬→퍼블리시 순서로 호출
환경 선택(Dev/Stage/Prod), 버전 입력(semver), 결과 토스트/로그
최근 배포 이력·활성 버전 표시
런북 내장
우측 패널에 “운영자 매뉴얼” 요약: curl 예시/롤백/권한/체크리스트
실패 시 재현 링크(Execution Trace URL) 바로가기
A/B 테스트 & 미리보기
동일 입력에 두 플로우/버전 비교: 응답시간/토큰/해결률(시뮬 기준)

4.2 컴포넌트/유틸 구조
/src/components/workflow-editor/
  ├─ WorkflowEditor.tsx
  ├─ nodes/{IntentNode|LLMNode|APINode|ConditionNode|LoopNode}.tsx
  ├─ panels/{NodePalette|Properties|Publish|Debug}.tsx
  ├─ utils/dsl/{toYaml.ts, fromYaml.ts, validate.ts}
  └─ services/coreClient.ts (upload/compile/simulate/publish/execute)

5) Core 측 구현 계획 (백엔드)
5.1 서비스 계층

registry.py — DSL 보관/버전/환경 라우팅
compiler.py — DSL→Graph(AST) 변환 + 스키마·정책 검증
simulator.py — Mock KB/API + LLM 샘플 경로 검증
publisher.py — Env Slot 스위칭(atomic), 롤백
executor/graph.py — 노드 타입 실행기(의도/LLM/API/조건/반복)
policy.py — SLA 타임아웃·모델 교체·상담사 승격
router.py — 모델 라우팅(대형↔경량, 요약 경유), 재시도
obs.py — Trace(OTel), Metrics(Prom), Logs(Loki), PII 마스킹 후 로그

5.2 노드 타입 실행 인터페이스
class NodeExecutor(Protocol):
    def run(self, ctx: ExecutionContext, cfg: dict) -> NodeResult:
        ...

# 예: LLM 노드
class LLMExecutor(NodeExecutor):
    def run(...):
        prompt = build_prompt(ctx, cfg)
        model = router.pick(cfg.get("model"), ctx)
        out = model.generate(prompt, temperature=cfg.get("temperature", 0.7))
        return NodeResult(outputs={"reply": out.text, "confidence": out.conf}, metrics=out.metrics)

5.3 정책 엔진 훅
전/후처리: before_step, after_step 훅
SLA 위반: on_sla_breach → fallback(model=slm-ko-3b)
감정/리스크: on_sentiment(angry) → escalate(agent_queue='refund')

6) DevOps/릴리즈/운영
6.1 CI/CD & 환경
GitHub Actions: 테스트→도커이미지→Helm Chart 패키징
ArgoCD(GitOps): Dev→Stage→Prod 릴리즈 파이프라인
시크릿 관리: Vault/Sealed Secret, JWT_PUBLIC_KEY, API Keys
이미지 태깅: core:v1.3.2+build77, studio:v0.9.0

6.2 모니터링/알림
Prometheus/Grafana: Latency, Success, Automation, TokenCost 대시보드
OpenTelemetry: execution_id 단일 추적, 샘플링율 환경별 분리
Loki: 워크플로우별 구조화 로그(PII Masked)
Alerting: SLA/에러율/비용 임계치 초과시 Slack/Webhook

6.3 보안/컴플라이언스
PII 마스킹(입/출력) + 접근제어(RBAC), 감사로그 보존기간 정책
레이트 리밋/IP 허용목록/서명된 웹훅
ISMS-P 가이드 반영 체크리스트(로그 보존, 암호화, 재해복구)

7) 롤아웃 타임라인 (8주 기준)
주차	목표	핵심 산출물
1주	스키마·엔드포인트 합의	DSL v1 스키마, OpenAPI 3.1(업/컴/시/배/실행)
2주	Studio Export/Import	toYaml/fromYaml/validate 유틸, 저장/불러오기 UI
3주	Registry/Compiler	DB 스키마, /workflows, /compile 동작
4주	Simulator/Publisher	/simulate, /publish/activate, Env Slot
5주	Executor/Policy	노드 5종 실행기, SLA/에스컬레이션/폴백 훅
6주	Model Router/RAG	대/경량 라우팅, 요약경유, KB 연결
7주	Observability/보안	OTel/Prom/Loki, PII Mask, RBAC/JWT
8주	하드닝/IR 패키지	A/B Test, 대시보드, IR 1-pager/Slide
8) 체크리스트(바로 실행)
 Studio: Export(YAML) / Import / Validate
 Studio: Publish(Dev/Stage/Prod), 배포 이력/활성표시
 Core: /workflows /compile /simulate /publish /activate
 Core: /workflow/{ns}/{name}/execute (권장 실행 API)
 Policy: SLA/fallback/escalation/비용 cap
 Observability: trace+metrics+logs+mask, 알림
 RBAC/JWT: workflow:* 스코프, 테넌트 격리
 GitOps: 버전 태깅·릴리즈 노트·롤백 플랜

9) 샘플 운영 커맨드(복붙)
# 업로드
curl -sX POST https://api.kainexa.local/api/v1/workflows \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/yaml" \
  --data-binary @refund-flow-1.3.2.yaml

# 컴파일
curl -sX POST https://api.kainexa.local/api/v1/workflows/compile \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -d '{"workflow_id":"cs/ecommerce/refund-flow","version":"1.3.2"}'

# 시뮬레이션
curl -sX POST https://api.kainexa.local/api/v1/workflows/simulate \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -d '{"workflow_id":"cs/ecommerce/refund-flow","version":"1.3.2","input":{"text":"환불요청","order_id":"A-10293"}}'

# 퍼블리시(prod)
curl -sX POST https://api.kainexa.local/api/v1/workflows/publish \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -d '{"workflow_id":"cs/ecommerce/refund-flow","version":"1.3.2","env":"prod"}'

# 실행
curl -sX POST https://api.kainexa.local/api/v1/workflow/cs/ecommerce/refund-flow/execute \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -d '{"session_id":"user-xyz","input":{"text":"환불하고 싶어요","order_id":"A-10293"},"context":{"channel":"web","language":"ko-KR"}}'

10) 리스크 & 대응

LLM 환각/정책 위반: Compiler 단계에서 금칙 토픽/어휘/액션 정적 검사 + 실행 시 감독자 후처리.
비용 급증: SLA 초과/장문 입력 시 요약→경량모델 경유, 토큰 한도 정책.
레거시 API 품질: Tool Connector를 표준 어댑터로 래핑(재시도/서킷브레이커/타임아웃).
릴리즈 장애: Env Slot 이중화 + Activate 롤백 원클릭.